# 正则表达式与文件格式化

正则表达式(Regular Expression)是通过一些特殊字符的排列，用以查找，替换，删除的一行或多行文字字符串

正则表达式的字符串按照表达方式依据不同的严谨度而分为基础正则表达式与扩展表达式

## １．基础正则表达式

由于正则表达式时用来处理字符串的一种方式，所以对字符排序有影响的语系就会对正则表达式结果有影响

### 语系对正则表达式的影响

如，在英文大小写的编码顺序中，zh_CN.big5及C这两种语系的输出结果分别如下：

* LANG=C时：0 1 2 3 ---A B C D ----Z a b c d --- z
* LANG=zh_CH时：0 1 2 3 --- a A b B c C --- z Z

所以[A-Z]包含的字符是不一样的

下面都是使用LANG=C来操作的，特殊符号的含义如下：

| 特殊符號            | 代表意義                                     |
| --------------- | ---------------------------------------- |
| [:alnum:]       | 代表英文大小寫字元及數字，亦即 0-9, A-Z, a-z            |
| [:alpha:]       | 代表任何英文大小寫字元，亦即 A-Z, a-z                  |
| [:blank:]       | 代表空白鍵與 [Tab] 按鍵兩者                        |
| [:cntrl:]       | 代表鍵盤上面的控制按鍵，亦即包括 CR, LF, Tab, Del.. 等等   |
| [:digit:]       | 代表數字而已，亦即 0-9                            |
| ```[:graph:]``` | 除了空白字元 (空白鍵與 [Tab] 按鍵) 外的其他所有按鍵          |
| [:lower:]       | 代表小寫字元，亦即 a-z                            |
| [:print:]       | 代表任何可以被列印出來的字元                           |
| [:punct:]       | 代表標點符號 (punctuation symbol)，亦即：" ' ? ! ; : # $... |
| [:upper:]       | 代表大寫字元，亦即 A-Z                            |
| [:space:]       | 任何會產生空白的字元，包括空白鍵, [Tab], CR 等等           |
| [:xdigit:]      | 代表 16 進位的數字類型，因此包括： 0-9, A-F, a-f 的數字與字元 |

尤其上表中的[:alnum:], [:alpha:], [:upper:], [:lower:], [:digit:] 這幾個一定要知道代表什麼意思，因為他要比 a-z 或 A-Z 的用途要確定的很！好了，底下就讓我們開始來玩玩進階版的 grep 吧！

### grep 的一些高级参数

```
$ grep [-A] [-B] [--color=auto] '搜索字符'　filename
-A: 后接数字num，表示匹配到的那行后num行都输出
-B: 后接数字num,表示匹配到的那行前num行都输出

$ grep -A -n '[:lower:]' 1.txt   <== file没有时默认为stdin
```

### 基础正则表达式字符

|                  RE 字符                   |                  意义与范例                   |
| :--------------------------------------: | :--------------------------------------: |
|                  ^word                   | 意义：待搜寻的字串(word)在行首！范例：搜寻行首为#开始的那一行，并列出行号```grep -n '^#' regular_express.txt``` |
| ```word$  | 意义：待搜寻的字串(word)在行尾！范例：将行尾为!的那一行列印出来，并列出行号grep -n '!$' regular_express.txt``` |                                          |
|                    .                     | 意义：代表『一定有一个任意字元』的字符！范例：搜寻的字串可以是(eve) (eae) (eee) (ee)，但不能仅有(ee) ！亦即e与e中间『一定』仅有一个字元，而空白字元也是字元！```grep -n 'ee' regular_express.txt`` |
|                    \                     | 意义：跳脱字符，将特殊符号的特殊意义去除！范例：搜寻含有单引号'的那一行！```grep -n \' regular_express.txt``` |
|                    *                     | 意义：重复零个到无穷多个的前一个RE字符范例：找出含有(es) (ess) (esss)等等的字串，注意，因为*可以是0个，所以es也是符合带搜寻字串。另外，因为*为重复『前一个RE字符』的符号，因此，在*之前必须要紧接着一个RE字符喔！例如任意字元则为grep -n  'ess＊'   regular_express.txt |
|                  [list]                  | 意义：字元集合的RE字符，里面列出想要撷取的字元！范例：搜寻含有(gl)或(gd)的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』，例如『 a[afl]y 』代表搜寻的字串可以是aay, afy, aly即[afl]代表a或f或l的意思！grep -n 'g[ld]' regular_express.txt |
|                 [n1-n2]                  | 意义：字元集合的RE字符，里面列出想要撷取的字元范围！范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[]中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在bash当中，需要确定LANG与LANGUAGE的变数是否正确！)例如所有大写字元则为[AZ]　　　　```grep -n '[AZ]' regular_express.txt``` |
|                 [^list]                  | 意义：字元集合的RE字符，里面列出不要的字串或范围！范例：搜寻的字串可以是(oog) (ood)但不能是(oot) ，那个^在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为```[^A-Z]```。但是，需要特别注意的是，如果以```grep -n [^AZ] regular_express.txt```来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个```[^AZ]```是『非大写字元』的意思，因为每一行均有非大写字元，例如第一行的"Open Source"就有p,e,n,o....等等的小写字```grep -n 'oo[^t]' regular_express.txt``` |
|                 \{n,m\}                  | 意义：连续n到m个的『前一个RE字符』意义：若为\{n\}则是连续n个的前一个RE字符，意义：若是\{n,\}则是连续n个以上的前一个RE字符！ 范例：在g与g之间有2个到3个的o存在的字串，亦即(goog)(gooog)   ```grep -n 'go\{2,3\}g' regular_express.txt``` |
|                   [^$]                   |                  表示空白字符                  |

注意:通配符和正则表达式是有区别的，如下：

```
# 获取所有以'a'字符开头的文件
$ ll  a*
$ ll  | grep -n '^a.*'   <==　需要搭配支持正则表达式的工具
```

### sed工具

sed本身是一个管道命令，可以用来分析stdin,且具有将数据进行替换，删除，新增，选取等特定功能

```
$ sed [-nefr] 动作
参数：
-n: 安静模式，只要经过sed处理的那一行才会被显示出
-e script: 直接在命令行模式下执行script
-f　file: 可以执行脚本内的指令
-r: 在脚本中使用扩展型正则表达式的语法
-i: 直接修改读取的文件内容，而不是由屏幕输出

动作说明：　[n1[,n2]] function
n1,n2: 表示要操作的数据行数区间
function有下面这些参数：
a: 新增，在下一行
c: 替换，后接的字符可以替换n1-n2之间的字符
d: 删除
i: 插入，在目前行的上一行
p: 打印，与-n参数一起用
s: 替换，可以和正则表达式搭配
```

1. 以行为单位的新增/删除功能

   ```
   # 将/etc/passwd的内容列出并且打印行号，同时，删除第2-5行
   $ nl /etc/passwd | sed '2,5d'

   # 在第二行后加上"drink tea"字样
   $ nl /etc/passwd | sed '2a drink tea'　　　<== 2i表示在第二行前

   # 在第二行后加两行字符串：
   $ nl /etc/passwd | sed '2a Drink tea or   \
   > drink tea'           <== 加入反斜杠换行
   ```

   ​

2. 以行为单位的替换与显示功能

   ```
   # 将第2-5行的内容替换为＂No 2-5 number＂
   $ nl /etc/passd | sed '2,5c No 2-5 number'

   # 仅列出/etc/passwd文件内的第5行到最后
   $ nl /ec/passwd | sed -n '5,$p'
   ```

   ​

3. 部分数据的查找和替换功能

   ```
   $ sed 's/要被替换的字符串/新的字符串/g'  <==　新的字符串为空时，删除被代替的字符串
   $ /sbin/ifcongig eth0 | grep 'inet addr' | sed 's/^.*addr//g' | sed 's/Bcast.*$//g'

   $ cat /etc/man.config | grep 'MAN' | sed 'S/#.*$//g' | sed'/^$/d'
   ```

   ​

4. 直接修改文件

   sed可以直接修改文件内容，而不需要重定向或管道

   ```
   $ 利用sed直接在regular_express.txt最后一行加入'# This is a test'
   $ sed -i '$a # This is a test' regular_express.txt
   ```

## ２．扩展正则表达式

前面的删除空白行与行首为#的行的表达式为

```
$ grep -v '^$' regular_express.txt | grep -v '^#'
```

使用扩展正则表达式可以写为：

```
$ egrep -v '^$|^#' regular_express.txt
```

| RE 字符 | 意义与范例                                    |
| ----- | ---------------------------------------- |
| +     | 意义：重复『一个或一个以上』的前一个RE字符范例：搜寻(god) (good) (goood)...等等的字串。那个o+代表『一个以上的o 』所以，底下的执行成果会将第1, 9, 13行列出来。egrep -n 'go+d' regular_express.txt |
| ?     | 意义：『零个或一个』的前一个RE字符范例：搜寻(gd) (god)这两个字串。那个o?代表『空的或1个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d'与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！^_^egrep -n 'go?d' regular_express.txt |
| \|    | 意义：用或( or )的方式找出数个字串范例：搜寻gd或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog呢？egrep -n 'gd\|good' regular_express.txt egrep -n 'gd\|good\|dog' regular_express.txt |
| ()    | 意义：找出『群组』字串范例：搜寻(glad)或(good)这两个字串，因为g与d是重复的，所以，我就可以将la与oo列于( )当中，并以\|来分隔开来，就可以啦！egrep -n 'g(la\|oo)d' regular_express.txt |
| ()+   | 意义：多个重复群组的判别范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！echo 'AxyzxyzxyzxyzC' \| egrep 'A(xyz)+C'上面的例子意思是说，我要找开头是A 结尾是C ，中间有一个以上的"xyz" 字串的意思～ |

## ３．文件的格式化和相关处理

### 格式化打印: printf

```
$ printf '打印格式'　实际内容
参数：
\a: 警告声
\b:　退格键
\f: 清除屏幕
\n: 输出新的一行
\r: Enter按键
\t: 水平的[tab]按键
\v: 垂直的[tab]按键
\xNN: NN为两位数的数字，可以转换数字为字符

$ printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat printf/txt) <== grep不是管道命令
```

### awk: 好用的数据处理工具

```
$ awk '条件类型　1{动作1} 条件类型２{动作2} ... ' filename
```

### 文件比较工具：

1. diff: diff通常是用在同一文件的新旧版本上(以行为单位)
2. cmp:　以字节为单位比较，通常用于二进制文件
3. patch: 与diff配合使用 

### 文件打印准备：pr

