# 认识学习bash

##１．认识bash

###简介

只要能操作应用程序的接口都叫shell.

Linux使用的shell版本较多，查询方法如下：

```
$ cat /etc/shells 
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash                  <==Linux默认的shell
/bin/rbash
/usr/bin/tmux
/usr/bin/screen
```

系统默认的shell可以用下面的命令查看：

```
$ cat /etc/passwd
```

### bash shell的功能

bash的主要优点如下：

1. 命令记忆功能

   bash会记录下你以前执行的指令，默认可达到１０００个．

   这些命令记录在.bash_history文件中．需要注意的是，这个文件记载的时前一次登录所执行的命令，本次登录执行的命令会先存在于内存中，当成功注销后，该命令记忆才会记录到.bash_history中．

2. 命令与文件补全功能（[Tab]）

3. 命令别名设置功能(alias)

4. 作业控制，前台，后台控制

5. 程序脚本(shell script)

6. 通配符(Wildcard)

### bash shell的内置命令：type

bash内置了很多命令，如：cd, umarsk等

使用type命令可以查看命令的特征：

```
$ type ls
ls is aliased to `ls --color=auto'     <== 别名
$ type cd
cd is a shell builtin　　　　　　　　　　 <== shell内置

```

### 命令的执行

可用'\'转义'[Enter]'，实现命令换行

## ２．shell的变量功能

### 变量的显示与设置：echo, unset

1. 变量的显示：echo

   ```
   $ echo $variable    <== 语法
   $ echo $PATH
   或
   $ echo ${PATH}
   ```

2. 变量的设置：＝

   ```
   $ myname = zjj
   $ echo $zjj
   ```

   ​

3. 变量的设置规则：

   3.1 变量与变量内容以一个符号＂＝＂来连接，如下所示：

   ​	"myname=jj"

   3.2 等号两边不能直接接空格

   ​	"myname =jj"和"myname=j  j"都是错误的

   3.3 变量名称只能是英文字母和数字，且开头字符不能是数字

   3.4 变量内容如有空格可使用双引号或单引号将变量内容结合起来但是：

   	> **双引号内的特殊字符如$等，可以保持原有的特性**
   	>
   	> **单引号内的特殊字符只是一般的字符**

   3.5 可用转义字符'\'将特殊符号（如：[Enter], $, \, 空格, !等）转义成一般字符

   3.6　在一串命令中，可能需要通过其他的命令提供的信息，可以使用```"`命令`"```或"$(命令)"

   ​	如：```version=$(uname -r)``` 则可用```echo $version``` 命令的到"4.4.0-87-generic"

   ​	进入内核模块目录：```cd /lib/modules/`uname -r`/kernel```

   3.7 若该变量为了增加变量内容时，则可以用```"$变量名称"``` 或```${变量}``` 累加内容，如下所示：

   ​	```PATH="$PATH":/home/bin``` <==双引号，保持$原有的特性

     或：```PATH=$SPATH:/home/bin```

     或：```PATH=${SPATH}:/home/bin```

   3.8 若该变量需要在其他子进程执行，则需要以export来使变量变为环境变量：

   ​	"export PATH"

   3.９通常大写字符为系统默认字符，所有自行设置的变量尽量使用小写字符

   3.10 取消变量的方法为使用"unset 变量名",如："$ unset myname"

### 环境变量的功能

1. 查看环境变量的命令：env, export

```
＃ 用env列出目前shell环境下的所欲环境变量与其内容
$ env
LC_PAPER=zh_CN.UTF-8
XDG_SESSION_ID=467
...
```

环境变量及其含义:

|    变量    |                    含义                    |
| :------: | :--------------------------------------: |
|   HOME   |                代表用户的主文件夹                 |
|  SHELL   |          标明目前这个环境使用的shell程序是哪个           |
| HISTSIZE |                存储历史命令的条数值                |
|   MAIL   |                 用户邮箱文件位置                 |
|   PATH   | 执行文件查找的路径,目录与目录之间以(:)隔开,文件的查找顺序来,所以目录的顺序很总要 |
|   LANG   |   语系数据,中文通常是:zh_CN.gb2312和zh_CN.UTF-8    |
|  RANDOM  |   随机数生成器,echo $RANDOM时会给个0~32768之间的随机数   |

2. 用set查看所有变量(环境变量和自定义变量)

比较重要的几个变量为:

> 1. PS1(提示符的设置)
>
>    ```c
>    $ set | grep PS1
>    PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
>
>    ```
>
>    PS1时我们的命令提示符,每次[Enter]时都会去读这个变量值,其主要参数如下:
>
>    |    参数    |                含义                 |
>    | :------: | :-------------------------------: |
>    |    \d    |      可以显示"星期月日",如"Mon Feb 2"      |
>    |    \H    |              完整的主机名               |
>    |    \h    |         仅取主机名第一个小数点之前的名字          |
>    |    \t    |      显示时间,为24小时格式的"HH:MM:SS"      |
>    |    \T    |      显示时间,为12小时格式的"HH:MM:SS"      |
>    |    \A    |       显示时间,为24小时格式的"HH:MM"        |
>    |    \@    |       显示时间,为12小时格式的"am/pm"        |
>    |    \u    |         目前用户的账号名称,如"root"         |
>    |    \v    |             BASH的版本信息             |
>    |    \w    |  完整的工作目录名称,由根目录泄气的目录名称,主文件夹会以~代替  |
>    |  \W(大写)  | 利用basename函数取得的工作目录名称,仅会列出最后一个目录名 |
>    | ```\#``` |             执行的第几个命令              |
>    | ```\$``` |        提示符,如果是root就为#,否则为$        |
>
>    如下命令：
>
>    ```
>    PS1='\e[;40m[\e[31;40m\u@fjcs \e[32;40m\w \e[33;40m\t \e[37;40m\#]\$ '
>    ```
>
>    ​
>
>    我们能够通过配置PS1变量使提示符成为彩色。在PS1中配置字符序列颜色的格式为：
>
>    ​   ``` \e[F;Bm\```   或　```\[\e[F;Bm\]```
>
>    ​    基本上是夹在 "\e["（转义开方括号）和 "m" 之间数字值。假如指定一个以上的数字代码，则用分号将他们分开。
>
>    ​    
>
>    ​    其中 F 为字体颜色，编号30~37； B 为背景色，编号40~47。
>
>
>    ​    可通过 \e[0m 关闭颜色输出；特别的，当B为1时，将显示加亮加粗的文字，请看下面的颜色表和代码表。
>
> ​    
>
>    ​    颜色表
>
> ​    
>
>    ​    前景 背景 颜色
>
>    ​    ---------------------------------------
>
> ​       30 40 黑色
>
> ​       31 41 红色
>
> ​       32 42 绿色
>
>    ​    33 43 黄色
>
>    ​    34 44 蓝色
>
> ​       35 45 紫色
>
>    ​    36 46 青色
>
>    ​    37 47 白色
>
> ​    
>
>    ​    代码 意义
>
>    ​    -------------------------
>
>    ​    0 OFF
>
>    ​    1 高亮显示
>
>    ​    4 underline
>
>    ​    5 闪烁
>
>    ​    7 反白显示
>
>    ​    8 不可见 
>
>    ​    ***假如想要配置终端提示符的样式只要把$PS1在~/.bahrc指定即可***
>
> 2. $ (本shell的ID)
>
>    shell的PID,用"echo $$"命令显示
>
> 3. ? (上个命令的回传码)
>
>    如果上个命令执行成功,则为0,执行错误则会返回错误码
>
> 4. OSTYPE, HOSTTYPE, MACHTYPE (主机硬盘与内核的等级)
>
> 5. export (自有变量转成环境变量)
>
>    子进程会继承父进程的环境变量,而不会继承自定义变量
>
>    ```
>    # 将自定义变量变为环境变量,使其可以被子进程bash使用
>    $ export 变量名
>    ```

### 影响显示结果的语系变量(locale)

查看本系统支持的语系:

```
$ locale -a
C
C.UTF-8
POSIX
en_US.utf8

```

我们可以通过修改如下环境变量来修订编码:

```
$ locale
LANG=en_US.UTF-8             <==主语言的环境
LANGUAGE=en_US:en          
LC_CTYPE="C"                 <==字符(文字)辨识的编码
LC_NUMERIC="C"               <==数字系统的显示数据
LC_TIME="C"                  <==时间系统的显示数据
LC_COLLATE="C"               <==字符串的比较与排序等
LC_MONETARY="C"              <==币值格式的显示等
LC_MESSAGES="C"              <==信息显示的内容,如菜单,错误信息等
LC_PAPER="C"
LC_NAME="C"
LC_ADDRESS="C"
LC_TELEPHONE="C"
LC_MEASUREMENT="C"
LC_IDENTIFICATION="C"
LC_ALL=C                     <==整体语系环境

```

**如果其他的语系变量都未被设置,则会被LANG或者是LC_ALL的语系变量代替**

### 变量的有效范围

### 变量键盘读取,数组与声明: read, array, declare

等待用户输入变量的值

1. read

   功能类似与c的scanf

   ```
   $ read [-pt] variable
   参数:
   -p: 后面可以接提示符
   -t: 后面可以接等待的"秒数"
   ```

   ```
   $ read atest

   # 提示用户输入信息,限三十秒
   $ read -p "Please input your name:   " -t 10 named
   Please input your name:   zjj
   $ echo $named
   zjj
   ```

   ​

2. declare/typeset

   这两个指令的功能都是**声明变量的类型**,如果使用declare后面并没有接任何参数,则功能和set一样

   declare的语法:

   ```
   $ declare [-aixr] variable
   参数:
   -a: 将后面名为variable 的变量定义为数组(array)类型
   -i: 将后面名为variable 的变量定义为整数(integer)类型
   -x: 用法与export相同,就是将后面的变量变成环境变量
   -r: 将变量修改为只读类型,该变量不可被更改内容,也不能重设
   ```

   ```
   # 让变量sum进行累加计算
   $ declare -i sum=1+2+3; echo $sum
   6
   # 将sum变为环境变量
   $ declare -x sum
   # 让sum变为非环境变量
   $ declare +x sum
   ```

   在默认情况下,bash 对变量有几个基本的规定:

   * 变量类型默认为"字符串",所以若不指定变量类型,1+2是个字符串而不是"计算式"
   * bash环境中的数值运算默认最毒能达到整数类型,所以1/3=0

3. 数组(array)变量类型

   ```
   $ var[1]=2
   $ var[2]=22
   $ var[3]=222
   $ echo "${var[1]}, ${var[2]}, ${var[3]}"
   2, 22, 222
   ```

   声明一个数组：
   declare -a array

   如果没有声明，按数组方式直接赋值给变量，BASH也认作数组：
   (1) array=(var1 var2 var3 ... varN)
   (2) array=([0]=var1 [1]=var2 [2]=var3 ... [n]=varN)
   (3) array[0]=var1
   ​    arrya[1]=var2
   ​    ...
   ​    array[n]=varN

   数组用法说明：
   ```${array[n]}```                     # 引用数组
   ```${array[*]} 或${array[@]} ```      # 数组所有成员
   ```${!array[*]} 或${!array[@]} ```    # 数组所有下标
   ```${#array[*]} 或${#array[@]}  ```   # 数组元素个数
   ```${#array[0]}  ```                 # 数组第一个成员的长度

   ```
   # COLOR=("red" "green" "yellow" "blue" [5]="orange")
   # echo ${#COLOR[*]}
   5
   # echo ${!COLOR[*]}
   0 1 2 3 5
   # for item in ${COLOR[*]}
   > do
   >     printf "   %s/n" $item
   > done
      red
      green
      yellow
      blue
      orange
   # for index in ${!COLOR[*]}
   > do
   >     printf "   %d/n" $index
   > done

      0
      1
      2
      3
      5

   注意数组下标可以有间断，上面的例子就缺少下标4，可以用单个数组元素赋值方法补上：
   # COLOR[4]="violet"
   # echo ${!COLOR[*]}
   0 1 2 3 4 5
   ```

   ​

   ### 与文件系统及程序的限制关系: ulimit

bash可以限制用户的某些资源,包括可以打开的文件数量,可以使用的cpu数,可以使用的内存总量等.用ulimit设置.

```
$ ulimit [-SHacdfltu] [配额]
参数:
-H: hard limit,严格的设置,必定不能超过设置的数值
-S: soft limit,警告的设置,可以超过这个值,但是会被警告
-a: 后面不接任何参数,可列出所有的限制配额
-c: 内核文件的最大容量(进程的错误信息)
-f: 此shell可创建的最大文件容量(一般肯能设置为2g),单位是KB
-d: 进程可以使用的最大segment内存容量
-l: 可用于锁的内存量
-t: 可使用的最大cpu时间,单位为秒
-u: 单一用户可以使用的最大进程数
```

### 变量内容的删除,替换和替换

1. 变量内容的删除与替换

   ***删除：***

   ```
   $ path=${PATH}
   $ echo $path
   /home/zjj/bin:/home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
   #如果不想要上述的zjj,可以将它删除
   $ echo ${path#/*zjj/bin:}
   /home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
   ＃会发现．．．/zjj/bin被删除了

   ＃参数解释：${vabriable#/*zjj/bin:}
   vabriable: 原本的变量名，如上面的path
   #: 这是重点，指从变量内容的最前面开始向右删除，且仅删除最短的那个　
   /*zjj/bin::只要删除的内容，*为通配符

   $ echo ${path#/*:}
   /home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin <==删除了第一个，对端删除

   $ echo ${path##/*:}
   /snap/bin　　　　<==最长删除
   ```

   由于#是从前往后删，如果想从后往前删，将#换成%就可以了

   ```
   $ echo {path%:*bin}  /home/zjj/bin:/home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
    
    $echo {path%%:*bin}
    /home/zjj/bin
   ```

   ***替换：***

   ```
   #将sbin替换成SBIN
   $ echo {path/sbin/SBIN}   /home/zjj/bin:/home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/SBIN:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
   #两个下划线之间是旧的字符，后面是新的字符，只会替换第一个

   $ echo {path//sbin/SBIN}  /home/zjj/bin:/home/zjj/.local/bin:/usr/local/cuda/bin：/usr/local/SBIN:/usr/local/bin:/usr/SBIN:/usr/bin:/SBIN:/bin:/usr/games:/usr/local/games:/snap/bin
   如果是两条下划线，则所有符合的情况都会替换

   ```

   **总结：**

   |      变量设置的方式       |                说明                 |
   | :----------------: | :-------------------------------: |
   |     ${变量#关键词}      | 若变量的内容从头开始的数据符合＂关键词＂，则将符合的最短数据删除  |
   |     ${变量##关键词}     | 若变量的内容从头开始的数据符合＂关键词＂，则将符合的最长数据删除  |
   |     ${变量%关键词}      | 若变量的内容从尾部向前的数据符合＂关键词＂，则将符合的最短数据删除 |
   |     ${变量%%关键词}     | 若变量的内容从尾部向前的数据符合＂关键词＂，则将符合的最长数据删除 |
   | ${变量/旧的字符串/新的字符串}  | 若变量的内容符合＂旧的字符串＂，则第一个旧字符串会被新的字符串替换 |
   | ${变量//旧的字符串/新的字符串} | 若变量的内容符合＂旧的字符串＂，则所有旧字符串都会被新的字符串替换 |


## ３．命令别名与历史命令

###命令别名设置nalias, unalias

查看目前所有的命名：

```
$ alias

alias alert='notify-send --urgency=low -i "([ ? = 0 ] && echo terminal || echo error)" "(history|tail -n1|sed -e '\''s/^\s[0-9]+\s//;s/[;&|]\s*alert//'\'')"'

alias egrep='egrep --color=auto'

alias fgrep='fgrep --color=auto'

alias grep='grep --color=auto'

alias l='ls -CF'

alias la='ls -A'

alias ll='ls -alF'

alias ls='ls --color=auto'

```

取消别名：

```$ unalias lm```

### 历史命令：history

bash有提供历史命令的服务，可以通过history命令查看：

```$ history```

取个别名：

```$ alias h='history'```